!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AR	srcs/libft/Makefile	/^AR=ar$/;"	m
ARFLAGS	srcs/libft/Makefile	/^ARFLAGS=rc$/;"	m
BONUS_OBJS	srcs/libft/Makefile	/^BONUS_OBJS=$(BONUS_SRCS:.c=.o)$/;"	m
BONUS_SRCS	srcs/libft/Makefile	/^BONUS_SRCS=ft_lstnew_bonus.c ft_lstadd_front_bonus.c ft_lstsize_bonus.c ft_lstlast_bonus.c ft_lstadd_back_bonus.c ft_lstdelone_bonus.c ft_lstclear_bonus.c ft_lstiter_bonus.c ft_lstmap_bonus.c$/;"	m
BUFFER_SIZE	srcs/libft/get_next_line.h	/^#  define BUFFER_SIZE /;"	d
BUILTIN_H	includes/builtin.h	/^# define BUILTIN_H$/;"	d
B_CD	includes/exec_structures.h	/^	B_CD,$/;"	e	enum:e_b_type
B_CD	includes/structures.h	/^	B_CD,$/;"	e	enum:e_b_type
B_ECHO	includes/exec_structures.h	/^	B_ECHO,$/;"	e	enum:e_b_type
B_ECHO	includes/structures.h	/^	B_ECHO,$/;"	e	enum:e_b_type
B_ENV	includes/exec_structures.h	/^	B_ENV,$/;"	e	enum:e_b_type
B_ENV	includes/structures.h	/^	B_ENV,$/;"	e	enum:e_b_type
B_EXIT	includes/exec_structures.h	/^	B_EXIT$/;"	e	enum:e_b_type
B_EXIT	includes/structures.h	/^	B_EXIT$/;"	e	enum:e_b_type
B_EXPORT	includes/exec_structures.h	/^	B_EXPORT,$/;"	e	enum:e_b_type
B_EXPORT	includes/structures.h	/^	B_EXPORT,$/;"	e	enum:e_b_type
B_FALSE	includes/exec_structures.h	/^	B_FALSE = -1,$/;"	e	enum:e_b_type
B_FALSE	includes/structures.h	/^	B_FALSE = -1,$/;"	e	enum:e_b_type
B_PWD	includes/exec_structures.h	/^	B_PWD,$/;"	e	enum:e_b_type
B_PWD	includes/structures.h	/^	B_PWD,$/;"	e	enum:e_b_type
B_UNSET	includes/exec_structures.h	/^	B_UNSET,$/;"	e	enum:e_b_type
B_UNSET	includes/structures.h	/^	B_UNSET,$/;"	e	enum:e_b_type
CC	Makefile	/^CC=cc$/;"	m
CC	srcs/libft/Makefile	/^CC=cc$/;"	m
CFLAGS	Makefile	/^CFLAGS=-Wextra -Wall -Werror -I.\/includes$/;"	m
CFLAGS	srcs/libft/Makefile	/^CFLAGS=-Wall -Wextra -Werror$/;"	m
DIR_HEADER	srcs/libft/Makefile	/^DIR_HEADER=.\/$/;"	m
DIR_SRCS	srcs/libft/Makefile	/^DIR_SRCS=.\/$/;"	m
ENV_H	includes/env.h	/^# define ENV_H$/;"	d
EXECUTE_H	includes/execute.h	/^# define EXECUTE_H$/;"	d
EXEC_STRUCTURES_H	includes/exec_structures.h	/^# define EXEC_STRUCTURES_H$/;"	d
EXPAND_H	includes/expand.h	/^# define EXPAND_H$/;"	d
FT_PRINTF_H	srcs/libft/ft_printf.h	/^# define FT_PRINTF_H$/;"	d
GET_NEXT_LINE_H	srcs/libft/get_next_line.h	/^# define GET_NEXT_LINE_H$/;"	d
HEADER	srcs/libft/Makefile	/^HEADER=libft.h$/;"	m
HEADERS	Makefile	/^HEADERS= .\/includes\/env.h \\$/;"	m
HEADERS_DIR	Makefile	/^HEADERS_DIR=.\/includes\/$/;"	m
INDEX	srcs/libft/libft.h	/^# define INDEX	/;"	d
JNDEX	srcs/libft/libft.h	/^# define JNDEX	/;"	d
KNDEX	srcs/libft/libft.h	/^# define KNDEX	/;"	d
LIBFT_H	srcs/libft/libft.h	/^# define LIBFT_H$/;"	d
MAN_OBJS	srcs/libft/Makefile	/^MAN_OBJS=$(MAN_SRCS:.c=.o)$/;"	m
MAN_SRCS	srcs/libft/Makefile	/^MAN_SRCS=ft_isalpha.c ft_isdigit.c ft_isalnum.c ft_isascii.c ft_isprint.c ft_strlen.c ft_memset.c ft_bzero.c ft_memcpy.c ft_memmove.c ft_strlcpy.c ft_strlcat.c ft_toupper.c ft_tolower.c ft_strchr.c ft_strrchr.c ft_strncmp.c ft_memchr.c ft_memcmp.c ft_strnstr.c ft_atoi.c ft_calloc.c ft_strdup.c ft_substr.c ft_strjoin.c ft_strtrim.c ft_split.c ft_itoa.c ft_strmapi.c ft_striteri.c ft_putchar_fd.c ft_putstr_fd.c ft_putnbr_fd.c ft_putendl_fd.c get_next_line.c get_next_line_utils.c$/;"	m
NAME	Makefile	/^NAME=minishell$/;"	m
NAME	srcs/libft/Makefile	/^NAME=libft.a$/;"	m
OBJS	Makefile	/^OBJS=$(SRCS:.c=.o)$/;"	m
OBJS	srcs/libft/Makefile	/^OBJS=$(BONUS_OBJS) $(MAN_OBJS) $(PRINTF_OBJS)$/;"	m
PARSER_H	includes/parser.h	/^# define PARSER_H$/;"	d
PARSE_DEFINE_H	includes/parse_define.h	/^# define PARSE_DEFINE_H$/;"	d
PARSE_STRUCT_H	includes/parse_struct.h	/^# define PARSE_STRUCT_H$/;"	d
PRINTF_OBJS	srcs/libft/Makefile	/^PRINTF_OBJS=$(PRINTF_SRCS:.c=.o)$/;"	m
PRINTF_SRCS	srcs/libft/Makefile	/^PRINTF_SRCS=ft_printf.c ft_printf2.c$/;"	m
PROMPT	includes/execute.h	/^# define PROMPT /;"	d
REDIRECTION_H	includes/redirection.h	/^# define REDIRECTION_H$/;"	d
RM	Makefile	/^RM=rm -fr$/;"	m
RM	srcs/libft/Makefile	/^RM=rm -fr$/;"	m
SIGNAL_HANDLER_H	includes/signal_handler.h	/^# define SIGNAL_HANDLER_H$/;"	d
SRCS	Makefile	/^SRCS = .\/srcs\/envs\/build_env_pack.c \\$/;"	m
STRUCTURES_H	includes/structures.h	/^# define STRUCTURES_H$/;"	d
TEMP_FILENAME	includes/redirection.h	/^# define TEMP_FILENAME /;"	d
TOKENIZER_H	includes/tokenizer.h	/^# define TOKENIZER_H$/;"	d
T_AND	includes/exec_structures.h	/^	T_AND,				\/\/ 논리 연산 AND "&&"$/;"	e	enum:e_type
T_AND	includes/structures.h	/^	T_AND,				\/\/ 논리 연산 AND "&&"$/;"	e	enum:e_type
T_CLOSE_BRACKET	includes/exec_structures.h	/^	T_CLOSE_BRACKET,	\/\/ 논리 연산 괄호 닫힘 ')'$/;"	e	enum:e_type
T_CLOSE_BRACKET	includes/structures.h	/^	T_CLOSE_BRACKET,	\/\/ 논리 연산 괄호 닫힘 ')'$/;"	e	enum:e_type
T_D_GREATER	includes/exec_structures.h	/^	T_D_GREATER,		\/\/ 리다이렉션 append ">>"$/;"	e	enum:e_type
T_D_GREATER	includes/structures.h	/^	T_D_GREATER,		\/\/ 리다이렉션 append ">>"$/;"	e	enum:e_type
T_D_LESSER	includes/exec_structures.h	/^	T_D_LESSER,			\/\/ 리다이렉션 Here_doc "<<"$/;"	e	enum:e_type
T_D_LESSER	includes/structures.h	/^	T_D_LESSER,			\/\/ 리다이렉션 Here_doc "<<"$/;"	e	enum:e_type
T_ERROR	includes/exec_structures.h	/^	T_ERROR = -1,		\/\/ 기본값 (syntax check때의 초깃값)$/;"	e	enum:e_type
T_ERROR	includes/structures.h	/^	T_ERROR = -1,		\/\/ 기본값 (syntax check때의 초깃값)$/;"	e	enum:e_type
T_GREATER	includes/exec_structures.h	/^	T_GREATER,			\/\/ 리다이렉션 '>'$/;"	e	enum:e_type
T_GREATER	includes/structures.h	/^	T_GREATER,			\/\/ 리다이렉션 '>'$/;"	e	enum:e_type
T_LESSER	includes/exec_structures.h	/^	T_LESSER,			\/\/ 리다이렉션 '<'$/;"	e	enum:e_type
T_LESSER	includes/structures.h	/^	T_LESSER,			\/\/ 리다이렉션 '<'$/;"	e	enum:e_type
T_NEWLINE	includes/exec_structures.h	/^	T_NEWLINE$/;"	e	enum:e_type
T_NEWLINE	includes/structures.h	/^	T_NEWLINE$/;"	e	enum:e_type
T_OPEN_BRACKET	includes/exec_structures.h	/^	T_OPEN_BRACKET,		\/\/ 논리 연산 괄호 열림 '('$/;"	e	enum:e_type
T_OPEN_BRACKET	includes/structures.h	/^	T_OPEN_BRACKET,		\/\/ 논리 연산 괄호 열림 '('$/;"	e	enum:e_type
T_OR	includes/exec_structures.h	/^	T_OR,				\/\/ 논리 연산 OR "||"$/;"	e	enum:e_type
T_OR	includes/structures.h	/^	T_OR,				\/\/ 논리 연산 OR "||"$/;"	e	enum:e_type
T_PIPE	includes/exec_structures.h	/^	T_PIPE,				\/\/ Pipe문자 '|'$/;"	e	enum:e_type
T_PIPE	includes/structures.h	/^	T_PIPE,				\/\/ Pipe문자 '|'$/;"	e	enum:e_type
T_SPACE	includes/exec_structures.h	/^	T_SPACE,			\/\/ 공백문자(보통 space)$/;"	e	enum:e_type
T_SPACE	includes/structures.h	/^	T_SPACE,			\/\/ 공백문자(보통 space)$/;"	e	enum:e_type
T_WORD	includes/exec_structures.h	/^	T_WORD,				\/\/ 문자$/;"	e	enum:e_type
T_WORD	includes/structures.h	/^	T_WORD,				\/\/ 문자$/;"	e	enum:e_type
UTILS_H	includes/utils.h	/^# define UTILS_H$/;"	d
add_cmd	srcs/parse/pipeline.c	/^void	add_cmd(t_cmd **list, t_cmd *cmd)$/;"	f
add_env_node	srcs/envs/build_env_pack.c	/^void	add_env_node(t_env_pack *pack, char *name, char *value)$/;"	f
add_sorted_node	srcs/envs/build_env_pack.c	/^void	add_sorted_node(t_env **sorted_head, t_env *new)$/;"	f
add_split	srcs/expand/expand_utils.c	/^void	add_split(t_c_expand *expand, char **split, int split_len, int idx)$/;"	f
add_str	srcs/execute/utils.c	/^char	**add_str(char **str, char *add)$/;"	f
add_str	srcs/parse/wildcard.c	/^char	**add_str(char **str, char *add)$/;"	f
add_token	srcs/parse/token_utils.c	/^void	add_token(t_token **list, t_token *token)$/;"	f
all_redirs	includes/exec_structures.h	/^	t_redir		*all_redirs;	\/\/ 해당 커맨드 블럭(pipe로 구분됨)의 모든 리다이렉션을 기록한 연결리스트, 실행부로 들어올 때, 모든 cmd_pack 구조체의 리다이렉션을 훑고 파일들을 열어야한다$/;"	m	struct:s_cmd_pack
all_redirs	includes/structures.h	/^	t_redir		*all_redirs;	\/\/ 해당 커맨드 블럭(pipe로 구분됨)의 모든 리다이렉션을 기록한 연결리스트, 실행부로 들어올 때, 모든 cmd_pack 구조체의 리다이렉션을 훑고 파일들을 열어야한다$/;"	m	struct:s_cmd_pack
appand_string	srcs/expand/expand_utils.c	/^char	*appand_string(char *result, char *original, int *start, int end)$/;"	f
append_exp_ptr	srcs/expand/expand_utils.c	/^void	append_exp_ptr(t_c_expand *expand, t_exp_pair *newpair)$/;"	f
append_redir	srcs/execute/redirections.c	/^void	append_redir(t_cmd **cmd, t_type type, char **fileinfo)$/;"	f
append_redir	srcs/execute/redirections/redirections.c	/^void	append_redir(t_cmd **cmd, t_type type, char **fileinfo)$/;"	f
b_check_redir	srcs/builtins/builtin_exec.c	/^void	b_check_redir(t_cmd *cur, int *std_fd, int *in_fd, int *out_fd)$/;"	f
b_exit	srcs/builtins/do_builtin2.c	/^void	b_exit(int code)$/;"	f
buf_check_n_join	srcs/libft/get_next_line.c	/^char	*buf_check_n_join(char *newline, char *buf, int *ret)$/;"	f
build_cmd_pack	srcs/execute/execute_utils2.c	/^t_cmd	*build_cmd_pack(t_ast *tree, t_env_pack *pack)$/;"	f
build_envp	srcs/envs/build_env_pack.c	/^void	build_envp(t_env_pack *pack, char **envp)$/;"	f
build_exp_pair	srcs/expand/expand_utils.c	/^void	build_exp_pair(t_c_expand *expand, char *ptr, int q_flag)$/;"	f
build_remain	srcs/libft/get_next_line.c	/^char	*build_remain(char *remain, char *str, int *ret)$/;"	f
builtin_fd_set	srcs/builtins/builtin_utils.c	/^void	builtin_fd_set(int *in_fd, int *out_fd, int *std_fd)$/;"	f
c_args	includes/exec_structures.h	/^	char		**c_args;		\/\/ builtin\/systemcall, arguments\/options를 담고 있는 캐릭터 이중 포인터$/;"	m	struct:s_cmd_pack
c_args	includes/structures.h	/^	char		**c_args;		\/\/ builtin\/systemcall, arguments\/options를 담고 있는 캐릭터 이중 포인터$/;"	m	struct:s_cmd_pack
check_bracket	srcs/parse/bracket.c	/^t_token	*check_bracket(t_token *start, t_token *end)$/;"	f
check_center_error	srcs/parse/check_ast_error.c	/^void	check_center_error(t_ast *ast, t_token *center)$/;"	f
check_end	srcs/parse/wildcard.c	/^int	check_end(char *filename, char *pattern, t_mark mark, int i)$/;"	f
check_env_name	srcs/builtins/builtin_utils.c	/^int	check_env_name(char **args, int i)$/;"	f
check_error	srcs/parse/check_ast_error.c	/^int	check_error(t_ast *ast)$/;"	f
check_front_center	srcs/parse/wildcard.c	/^int	check_front_center(char *filename, char *pattern, t_mark *mark, int i)$/;"	f
check_if_single_pair	srcs/parse/bracket.c	/^int	check_if_single_pair(t_token *start, t_token *end)$/;"	f
check_is_builtin	srcs/builtins/builtin_exec.c	/^enum e_b_type	check_is_builtin(char *arg)$/;"	f
check_pipe_in_bracket	srcs/parse/bracket.c	/^t_token	*check_pipe_in_bracket(t_token *start, t_token *end)$/;"	f
check_redirection_error	srcs/parse/check_ast_error.c	/^void	check_redirection_error(t_ast *ast)$/;"	f
check_remain	srcs/libft/get_next_line.c	/^int	check_remain(char *remain, char **newline)$/;"	f
check_res	srcs/builtins/builtin_utils.c	/^int	check_res(int res, t_env_pack *pack, char *path, char **args)$/;"	f
check_sign	srcs/builtins/builtin_utils.c	/^int	check_sign(char *str)$/;"	f
check_wildfixes	srcs/parse/wildcard.c	/^int	check_wildfixes(char *filename, __uint8_t type, char *pattern)$/;"	f
content	srcs/libft/libft.h	/^	void			*content;$/;"	m	struct:s_list
count_words	srcs/libft/ft_split.c	/^static size_t	count_words(char const *str, char c)$/;"	f	file:
delete_env	srcs/envs/env_utils.c	/^void	delete_env(char *name, t_env_pack *package)$/;"	f
delete_quotes	srcs/expand/expand.c	/^void	delete_quotes(t_c_expand *exp)$/;"	f
depths	includes/exec_structures.h	/^	int			depths;				\/\/ 현재 몇 번째 가지(재귀)에 있는지 확인용$/;"	m	struct:s_info
detact_exitcode	srcs/execute/redir_utils.c	/^int	detact_exitcode(int temp)$/;"	f
detact_exitcode	srcs/execute/redirections/redir_utils.c	/^int	detact_exitcode(int temp)$/;"	f
detact_f	srcs/libft/ft_printf.c	/^int	detact_f(char *format, va_list ap)$/;"	f
do_cd	srcs/builtins/do_builtin.c	/^int	do_cd(char **args, t_env_pack *pack)$/;"	f
do_echo	srcs/builtins/do_builtin.c	/^int	do_echo(char **args, t_env_pack *pack)$/;"	f
do_env	srcs/builtins/do_builtin2.c	/^int	do_env(char **args, t_env_pack *pack)$/;"	f
do_execution	srcs/execute/execute.c	/^void	do_execution(t_ast *tree, t_env_pack *pack, t_info *info)$/;"	f
do_exit	srcs/builtins/do_builtin2.c	/^int	do_exit(char **args, t_env_pack *pack)$/;"	f
do_expand	srcs/expand/do_expand.c	/^void	do_expand(t_c_expand *expand, t_env_pack *pack, int flag)$/;"	f
do_export	srcs/builtins/do_builtin2.c	/^int	do_export(char **args, t_env_pack *pack)$/;"	f
do_heredoc	srcs/execute/do_heredoc.c	/^int	do_heredoc(t_redir *temp, char *f_name, t_env_pack *pack)$/;"	f
do_heredoc	srcs/execute/redirections/do_heredoc.c	/^int	do_heredoc(t_redir *temp, char *f_name, t_env_pack *pack)$/;"	f
do_pwd	srcs/builtins/do_builtin.c	/^int	do_pwd(char **args, t_env_pack *pack)$/;"	f
do_unset	srcs/builtins/do_builtin2.c	/^int	do_unset(char **args, t_env_pack *pack)$/;"	f
e_b_type	includes/exec_structures.h	/^enum	e_b_type$/;"	g
e_b_type	includes/structures.h	/^enum	e_b_type$/;"	g
e_type	includes/exec_structures.h	/^enum	e_type$/;"	g
e_type	includes/structures.h	/^enum	e_type$/;"	g
end	includes/exec_structures.h	/^	struct s_token	*end;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_token
end	includes/parse_struct.h	/^	int	end;$/;"	m	struct:s_mark
end	includes/structures.h	/^	struct s_token	*end;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_token
end	srcs/parse/pipeline.c	/^	t_token	*end;$/;"	m	struct:s_cmd	file:
envp	includes/exec_structures.h	/^	char	**envp;			\/\/ 이중 캐릭터 포인터, 실행부에서 execve할때 넘겨줘야함, 만약 추가되거나 제거된 환경변수가 있으면 그걸 적용하기 위해 export\/unset할때 알맞게 업데이트해야함$/;"	m	struct:s_env_pack
envp	includes/structures.h	/^	char	**envp;			\/\/ 이중 캐릭터 포인터, 실행부에서 execve할때 넘겨줘야함, 만약 추가되거나 제거된 환경변수가 있으면 그걸 적용하기 위해 export\/unset할때 알맞게 업데이트해야함$/;"	m	struct:s_env_pack
error	includes/exec_structures.h	/^	char			*error;$/;"	m	struct:s_ast
error	includes/structures.h	/^	char			*error;$/;"	m	struct:s_ast
exec_builtin	srcs/builtins/builtin_exec.c	/^int	exec_builtin(char **args, t_env_pack *pack)$/;"	f
exec_parent	srcs/execute/execute_utils.c	/^void	exec_parent(t_info *info)$/;"	f
execute	srcs/execute/execute.c	/^void	execute(t_ast *tree, t_env_pack *pack, t_info *info)$/;"	f
execute_cmd	srcs/execute/execute.c	/^void	execute_cmd(t_cmd *cmd, t_env_pack *envs, t_info *info)$/;"	f
execute_pipe	srcs/execute/execute.c	/^void	execute_pipe(t_ast *tree, t_env_pack *pack, t_info *info, int level)$/;"	f
exit_status	includes/exec_structures.h	/^	int			exit_status;$/;"	m	struct:s_info
exp_name	includes/exec_structures.h	/^	char	*exp_name;		\/\/ 환경변수 이름!(나 좀 짱인듯)$/;"	m	struct:s_exp_pair
exp_name	includes/structures.h	/^	char	*exp_name;		\/\/ 환경변수 이름!(나 좀 짱인듯)$/;"	m	struct:s_exp_pair
exp_num	includes/exec_structures.h	/^	int			exp_num;		\/\/ '$' 갯수(확장여부 상관없이)$/;"	m	struct:s_expand
exp_num	includes/structures.h	/^	int			exp_num;		\/\/ '$' 갯수(확장여부 상관없이)$/;"	m	struct:s_expand
exp_pos	includes/exec_structures.h	/^	char	*exp_pos;		\/\/ 확장문자 위치$/;"	m	struct:s_exp_pair
exp_pos	includes/structures.h	/^	char	*exp_pos;		\/\/ 확장문자 위치$/;"	m	struct:s_exp_pair
exp_ptrs	includes/exec_structures.h	/^	t_exp_pair	**exp_ptrs;		\/\/ original을 돌면서 찾은 '$' 위치들과$/;"	m	struct:s_expand
exp_ptrs	includes/structures.h	/^	t_exp_pair	**exp_ptrs;		\/\/ original을 돌면서 찾은 '$' 위치들과$/;"	m	struct:s_expand
expand	srcs/expand/expand.c	/^char	**expand(char *data, t_env_pack *package, int flag)$/;"	f
expand_add	srcs/expand/do_expand.c	/^void	expand_add(t_c_expand *expand, char *temp)$/;"	f
expand_join	srcs/expand/do_expand.c	/^void	expand_join(t_c_expand *expand, char *temp)$/;"	f
expand_wildcard	srcs/parse/wildcard.c	/^char	**expand_wildcard(char *arg)$/;"	f
fd	includes/exec_structures.h	/^	int			fd;				\/\/ filename[1] 을 open했을때 반환받는 fd값, type == T_D_LESSER ("<<") 일 경우에는 filename[0]을 DELIMITER로 설정하고 heredoc을 실행한다.$/;"	m	struct:s_redir
fd	includes/structures.h	/^	int			fd;				\/\/ filename[1] 을 open했을때 반환받는 fd값, type == T_D_LESSER ("<<") 일 경우에는 filename[0]을 DELIMITER로 설정하고 heredoc을 실행한다.$/;"	m	struct:s_redir
filename	includes/exec_structures.h	/^	char		**filename;		\/\/ 이중 포인터인 이유는 ambigious redirection 에러처리를 위함(확장 예외처리)$/;"	m	struct:s_redir
filename	includes/structures.h	/^	char		**filename;		\/\/ 이중 포인터인 이유는 ambigious redirection 에러처리를 위함(확장 예외처리)$/;"	m	struct:s_redir
fill_nbr	srcs/libft/ft_printf2.c	/^void	fill_nbr(char *str, long n, char format, size_t len)$/;"	f
find_env	srcs/envs/env_utils.c	/^t_env	*find_env(char *name, t_env_pack *package)$/;"	f
find_env_name	srcs/expand/expand_utils.c	/^char	*find_env_name(char *ptr)$/;"	f
find_len	srcs/libft/ft_printf2.c	/^size_t	find_len(long n, int base)$/;"	f
find_mem_len	srcs/libft/ft_printf2.c	/^size_t	find_mem_len(unsigned long long nb)$/;"	f
find_position	srcs/expand/expand.c	/^void	find_position(t_c_expand *expand)$/;"	f
fork_num	includes/exec_structures.h	/^	int			fork_num;			\/\/ 몇번 fork()되었는지 기록, wait해야할 프로세스의 개수를 알아야 함$/;"	m	struct:s_info
free_all	srcs/libft/get_next_line.c	/^void	*free_all(char **remain, char *newline)$/;"	f
free_ast	srcs/parse/ast_utils.c	/^void	free_ast(t_ast **ast)$/;"	f
free_cmd	srcs/execute/execute_utils2.c	/^void	free_cmd(t_cmd *cmd)$/;"	f
free_envs	srcs/envs/env_utils.c	/^void	free_envs(t_env *head)$/;"	f
free_expand	srcs/expand/expand.c	/^void	free_expand(t_c_expand *expand)$/;"	f
free_node	srcs/parse/ast_utils.c	/^void	free_node(t_ast **node)$/;"	f
free_token	srcs/parse/token_utils.c	/^void	free_token(t_token **token)$/;"	f
free_tokens	srcs/parse/token_utils.c	/^void	free_tokens(t_token **tokens)$/;"	f
ft_assert	srcs/execute/utils.c	/^void	ft_assert(int expression, const char *arg, int exit_num)$/;"	f
ft_atoi	srcs/libft/ft_atoi.c	/^int	ft_atoi(const char *str)$/;"	f
ft_bzero	srcs/libft/ft_bzero.c	/^void	ft_bzero(void *s, size_t n)$/;"	f
ft_calloc	srcs/libft/ft_calloc.c	/^void	*ft_calloc(size_t count, size_t size)$/;"	f
ft_dup2	srcs/execute/pipe_utils.c	/^void	ft_dup2(t_info *info)$/;"	f
ft_execve	srcs/execute/execute_utils2.c	/^void	ft_execve(t_cmd *cmd, t_env_pack *envs)$/;"	f
ft_free_all	srcs/libft/ft_split.c	/^static char	**ft_free_all(char **strings)$/;"	f	file:
ft_isalnum	srcs/libft/ft_isalnum.c	/^int	ft_isalnum(int c)$/;"	f
ft_isalpha	srcs/libft/ft_isalpha.c	/^int	ft_isalpha(int c)$/;"	f
ft_isascii	srcs/libft/ft_isascii.c	/^int	ft_isascii(int c)$/;"	f
ft_isdigit	srcs/libft/ft_isdigit.c	/^int	ft_isdigit(int c)$/;"	f
ft_islower	srcs/libft/ft_isalpha.c	/^static int	ft_islower(int c)$/;"	f	file:
ft_isprint	srcs/libft/ft_isprint.c	/^int	ft_isprint(int c)$/;"	f
ft_isupper	srcs/libft/ft_isalpha.c	/^static int	ft_isupper(int c)$/;"	f	file:
ft_itoa	srcs/libft/ft_itoa.c	/^char	*ft_itoa(int n)$/;"	f
ft_lstadd_back	srcs/libft/ft_lstadd_back_bonus.c	/^void	ft_lstadd_back(t_list **lst, t_list *new)$/;"	f
ft_lstadd_front	srcs/libft/ft_lstadd_front_bonus.c	/^void	ft_lstadd_front(t_list **lst, t_list *new)$/;"	f
ft_lstclear	srcs/libft/ft_lstclear_bonus.c	/^void	ft_lstclear(t_list **lst, void (*del)(void *))$/;"	f
ft_lstdelone	srcs/libft/ft_lstdelone_bonus.c	/^void	ft_lstdelone(t_list *lst, void (*del)(void *))$/;"	f
ft_lstiter	srcs/libft/ft_lstiter_bonus.c	/^void	ft_lstiter(t_list *lst, void (*f)(void *))$/;"	f
ft_lstlast	srcs/libft/ft_lstlast_bonus.c	/^t_list	*ft_lstlast(t_list *lst)$/;"	f
ft_lstmap	srcs/libft/ft_lstmap_bonus.c	/^t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))$/;"	f
ft_lstnew	srcs/libft/ft_lstnew_bonus.c	/^t_list	*ft_lstnew(void *content)$/;"	f
ft_lstsize	srcs/libft/ft_lstsize_bonus.c	/^int	ft_lstsize(t_list *lst)$/;"	f
ft_memchr	srcs/libft/ft_memchr.c	/^void	*ft_memchr(const void *s, int c, size_t n)$/;"	f
ft_memcmp	srcs/libft/ft_memcmp.c	/^int	ft_memcmp(const void *s1, const void *s2, size_t n)$/;"	f
ft_memcpy	srcs/libft/ft_memcpy.c	/^void	*ft_memcpy(void *dst, const void *src, size_t n)$/;"	f
ft_memmove	srcs/libft/ft_memmove.c	/^void	*ft_memmove(void *dst, const void *src, size_t len)$/;"	f
ft_memset	srcs/libft/ft_memset.c	/^void	*ft_memset(void *b, int c, size_t len)$/;"	f
ft_perror	srcs/execute/execute_utils2.c	/^void	ft_perror(const char *str, int exit_num)$/;"	f
ft_printf	srcs/libft/ft_printf.c	/^int	ft_printf(const char *format, ...)$/;"	f
ft_putchar	srcs/libft/ft_printf.c	/^int	ft_putchar(int c)$/;"	f
ft_putchar_fd	srcs/libft/ft_putchar_fd.c	/^void	ft_putchar_fd(char c, int fd)$/;"	f
ft_putendl_fd	srcs/libft/ft_putendl_fd.c	/^void	ft_putendl_fd(char *s, int fd)$/;"	f
ft_putmem	srcs/libft/ft_printf2.c	/^int	ft_putmem(unsigned long long nb)$/;"	f
ft_putnbr	srcs/libft/ft_printf2.c	/^int	ft_putnbr(long n, char format, int base)$/;"	f
ft_putnbr_fd	srcs/libft/ft_putnbr_fd.c	/^void	ft_putnbr_fd(int n, int fd)$/;"	f
ft_putstr	srcs/libft/ft_printf.c	/^int	ft_putstr(char *s)$/;"	f
ft_putstr_fd	srcs/libft/ft_putstr_fd.c	/^void	ft_putstr_fd(char *s, int fd)$/;"	f
ft_split	srcs/libft/ft_split.c	/^char	**ft_split(char const *s, char c)$/;"	f
ft_strchr	srcs/libft/ft_strchr.c	/^char	*ft_strchr(const char *s, int c)$/;"	f
ft_strcmp	srcs/libft/ft_strncmp.c	/^int	ft_strcmp(const char *s1, const char *s2)$/;"	f
ft_strdup	srcs/libft/ft_strdup.c	/^char	*ft_strdup(const char *s1)$/;"	f
ft_strdup2	srcs/libft/ft_split.c	/^static char	*ft_strdup2(char const *src, int start, int end)$/;"	f	file:
ft_striteri	srcs/libft/ft_striteri.c	/^void	ft_striteri(char *s, void (*f)(unsigned int, char*))$/;"	f
ft_strjoin	srcs/libft/ft_strjoin.c	/^char	*ft_strjoin(char const *s1, char const *s2)$/;"	f
ft_strlcat	srcs/libft/ft_strlcat.c	/^size_t	ft_strlcat(char *dst, const char *src, size_t dstsize)$/;"	f
ft_strlcpy	srcs/libft/ft_strlcpy.c	/^size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)$/;"	f
ft_strlen	srcs/libft/ft_strlen.c	/^size_t	ft_strlen(const char *s)$/;"	f
ft_strmapi	srcs/libft/ft_strmapi.c	/^char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))$/;"	f
ft_strncmp	srcs/libft/ft_strncmp.c	/^int	ft_strncmp(const char *s1, const char *s2, size_t n)$/;"	f
ft_strnstr	srcs/libft/ft_strnstr.c	/^char	*ft_strnstr(const char *haystack, const char *needle, size_t len)$/;"	f
ft_strrchr	srcs/libft/ft_strrchr.c	/^char	*ft_strrchr(const char *s, int c)$/;"	f
ft_strtrim	srcs/libft/ft_strtrim.c	/^char	*ft_strtrim(char const *s1, char const *set)$/;"	f
ft_substr	srcs/libft/ft_substr.c	/^char	*ft_substr(char const *s, unsigned int start, size_t len)$/;"	f
ft_tolower	srcs/libft/ft_tolower.c	/^int	ft_tolower(int c)$/;"	f
ft_toupper	srcs/libft/ft_toupper.c	/^int	ft_toupper(int c)$/;"	f
ft_wait	srcs/execute/pipe_utils.c	/^void	ft_wait(t_info *info, t_env_pack *pack)$/;"	f
g_exit_status	includes/exec_structures.h	/^int							g_exit_status;$/;"	v
g_exit_status	includes/structures.h	/^int							g_exit_status;$/;"	v
g_status	srcs/parse/signal.c	/^volatile sig_atomic_t	g_status = 0;$/;"	v
generate_ast	srcs/parse/ast.c	/^void	generate_ast(t_ast **ast, t_token *start, t_token *end)$/;"	f
get_bracket_flag	srcs/parse/bracket.c	/^int	get_bracket_flag(t_token **start, t_token **end, \\$/;"	f
get_center	srcs/parse/center.c	/^t_token	*get_center(t_ast *ast, t_token *start, t_token *end)$/;"	f
get_exitstat	srcs/execute/execute.c	/^int	get_exitstat(t_env_pack *pack)$/;"	f
get_len	srcs/libft/ft_itoa.c	/^static void	get_len(int nb, int *len, int *sign)$/;"	f	file:
get_line	srcs/parse/signal.c	/^char	*get_line(char *prompt)$/;"	f
get_logical_exp	srcs/parse/center.c	/^t_token	*get_logical_exp(t_ast *ast, t_token *start, t_token *end)$/;"	f
get_meta1	srcs/parse/get_token.c	/^int	get_meta1(char *line, char **string, t_type *type)$/;"	f
get_meta2	srcs/parse/get_token.c	/^int	get_meta2(char *line, char **string, t_type *type)$/;"	f
get_next_line	srcs/libft/get_next_line.c	/^char	*get_next_line(int fd)$/;"	f
get_pipeline	srcs/parse/center.c	/^t_token	*get_pipeline(t_ast *ast, t_token *start, t_token *end)$/;"	f
get_quote	srcs/parse/get_token.c	/^int	get_quote(char *line, int *flag, int *idx)$/;"	f
get_type	srcs/parse/tokenizer.c	/^t_type	get_type(char *string, int i)$/;"	f
get_word	srcs/parse/tokenizer.c	/^int	get_word(char *line, char **string, t_type *type)$/;"	f
gnl_memcpy	srcs/libft/get_next_line_utils.c	/^void	*gnl_memcpy(void *dst, void *src, int n)$/;"	f
gnl_strnlen	srcs/libft/get_next_line_utils.c	/^int	gnl_strnlen(char *str, int type)$/;"	f
greater	srcs/libft/ft_memmove.c	/^static void	greater(unsigned char *dst, unsigned char *src, size_t len)$/;"	f	file:
greater_address	srcs/libft/ft_memmove.c	/^static int	greater_address(void *dst, const void *src)$/;"	f	file:
heredoc	srcs/execute/do_heredoc.c	/^int	heredoc(t_redir *target, t_env_pack *pack)$/;"	f
heredoc	srcs/execute/redirections/do_heredoc.c	/^int	heredoc(t_redir *target, t_env_pack *pack)$/;"	f
heredoc_expander	srcs/execute/do_heredoc.c	/^void	heredoc_expander(int fd, char *input, t_env_pack *pack, int flag)$/;"	f
heredoc_expander	srcs/execute/redirections/do_heredoc.c	/^void	heredoc_expander(int fd, char *input, t_env_pack *pack, int flag)$/;"	f
heredoc_q_flag	srcs/execute/redir_utils.c	/^int	heredoc_q_flag(char *str)$/;"	f
heredoc_q_flag	srcs/execute/redirections/redir_utils.c	/^int	heredoc_q_flag(char *str)$/;"	f
in_redirs	includes/exec_structures.h	/^	t_redir		*in_redirs;		\/\/ 최종적으로 사용될 input redirection('<', "<<")$/;"	m	struct:s_cmd_pack
in_redirs	includes/structures.h	/^	t_redir		*in_redirs;		\/\/ 최종적으로 사용될 input redirection('<', "<<")$/;"	m	struct:s_cmd_pack
init_ast	srcs/parse/ast_utils.c	/^t_ast	*init_ast(t_token *tokens)$/;"	f
insert_num	srcs/libft/ft_itoa.c	/^static void	insert_num(int nb, char *num_string, int *i)$/;"	f	file:
is_dir	srcs/execute/execute_utils.c	/^int	is_dir(char *str)$/;"	f
is_meta1	srcs/parse/meta.c	/^int	is_meta1(char c)$/;"	f
is_meta2	srcs/parse/meta.c	/^int	is_meta2(char c)$/;"	f
is_redirection	srcs/parse/ast_utils.c	/^int	is_redirection(t_type type)$/;"	f
is_route	srcs/execute/execute_utils.c	/^int	is_route(char *str)$/;"	f
is_set	srcs/libft/ft_strtrim.c	/^static int	is_set(char const *set, char c)$/;"	f	file:
is_space	srcs/libft/ft_atoi.c	/^int	is_space(char c)$/;"	f
join_remain	srcs/expand/do_expand.c	/^void	join_remain(t_c_expand *expand, int len)$/;"	f
last_cmd	srcs/parse/pipeline.c	/^t_cmd	*last_cmd(t_cmd *list)$/;"	f
last_pid	includes/exec_structures.h	/^	pid_t		last_pid;			\/\/ 가장 마지막에 fork()된 프로세스 id, exit code 확인용$/;"	m	struct:s_info
last_token	srcs/parse/token_utils.c	/^t_token	*last_token(t_token *list)$/;"	f
left	includes/exec_structures.h	/^	struct s_ast	*left;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_ast
left	includes/structures.h	/^	struct s_ast	*left;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_ast
left_ptr	includes/structures.h	/^	void		*left_ptr;		\/\/ 왼쪽 branch$/;"	m	struct:s_tree
logical_exp	srcs/execute/execute.c	/^void	logical_exp(t_ast *tree, t_env_pack *pack, t_info *info)$/;"	f
main	srcs/testmain.c	/^int	main(int ac, char *av[], char *envp[])$/;"	f
make_envp	srcs/execute/execute_utils.c	/^char	**make_envp(t_env_pack *envs)$/;"	f
merge_strs	srcs/execute/utils.c	/^char	**merge_strs(char **orig, char **new_strs)$/;"	f
name	includes/exec_structures.h	/^	char			*name;			\/\/ 환경변수 Key값 ($USER=yusekim 에서 'USER' 부분)$/;"	m	struct:s_env
name	includes/structures.h	/^	char			*name;			\/\/ 환경변수 Key값 ($USER=yusekim 에서 'USER' 부분)$/;"	m	struct:s_env
new_cmd	srcs/parse/pipeline.c	/^t_cmd	*new_cmd(t_token *start, t_token *end)$/;"	f
new_token	srcs/parse/token_utils.c	/^t_token	*new_token(char *string, t_type type)$/;"	f
next	includes/exec_structures.h	/^	struct s_token	*next;		\/\/ 다음 node$/;"	m	struct:s_token	typeref:struct:s_token::s_token
next	includes/exec_structures.h	/^	t_redir		*next;			\/\/ next node$/;"	m	struct:s_redir
next	includes/structures.h	/^	struct s_token	*next;		\/\/ 다음 node$/;"	m	struct:s_token	typeref:struct:s_token::s_token
next	includes/structures.h	/^	t_redir		*next;			\/\/ next node$/;"	m	struct:s_redir
next	srcs/libft/libft.h	/^	struct s_list	*next;$/;"	m	struct:s_list	typeref:struct:s_list::s_list
next	srcs/parse/pipeline.c	/^	t_cmd	*next;$/;"	m	struct:s_cmd	file:
open_check	srcs/execute/redirections.c	/^int	open_check(t_redir *temp)$/;"	f
open_check	srcs/execute/redirections/redirections.c	/^int	open_check(t_redir *temp)$/;"	f
origin_head	includes/exec_structures.h	/^	t_env	*origin_head;	\/\/ envp 순서대로 받았을때의 head node$/;"	m	struct:s_env_pack
origin_head	includes/structures.h	/^	t_env	*origin_head;	\/\/ envp 순서대로 받았을때의 head node$/;"	m	struct:s_env_pack
origin_last	includes/exec_structures.h	/^	t_env	*origin_last;	\/\/ envp 순서대로 받았을때의 last node, export 빌트인 시 여기 뒤에 추가한다.$/;"	m	struct:s_env_pack
origin_last	includes/structures.h	/^	t_env	*origin_last;	\/\/ envp 순서대로 받았을때의 last node, export 빌트인 시 여기 뒤에 추가한다.$/;"	m	struct:s_env_pack
origin_next	includes/exec_structures.h	/^	struct s_env	*origin_next;	\/\/ envp 들어온 순서대로 next node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
origin_next	includes/structures.h	/^	struct s_env	*origin_next;	\/\/ envp 들어온 순서대로 next node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
origin_prev	includes/exec_structures.h	/^	struct s_env	*origin_prev;	\/\/ envp 들어온 순서대로 prev node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
origin_prev	includes/structures.h	/^	struct s_env	*origin_prev;	\/\/ envp 들어온 순서대로 prev node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
original	includes/exec_structures.h	/^	char		*original;$/;"	m	struct:s_expand
original	includes/structures.h	/^	char		*original;$/;"	m	struct:s_expand
out_redirs	includes/exec_structures.h	/^	t_redir		*out_redirs;	\/\/ 최종적으로 사용될 output redirection('>', ">>")$/;"	m	struct:s_cmd_pack
out_redirs	includes/structures.h	/^	t_redir		*out_redirs;	\/\/ 최종적으로 사용될 output redirection('>', ">>")$/;"	m	struct:s_cmd_pack
path_join	srcs/execute/execute_utils.c	/^char	*path_join(char *path, char *arg)$/;"	f
pipe_fds	includes/exec_structures.h	/^	int			pipe_fds[2];			\/\/ pipe()의 결과물을 기록한다. 3개짜리 int배열이고 첫 두개는 pipe()의 결과물, 3번째칸에는 다중 파이프때의 이전에 사용한 파이프의 fd$/;"	m	struct:s_info
prev	includes/exec_structures.h	/^	struct s_token	*prev;		\/\/ 이전 node (syntax error 체크때 유용했었음)$/;"	m	struct:s_token	typeref:struct:s_token::s_token
prev	includes/structures.h	/^	struct s_token	*prev;		\/\/ 이전 node (syntax error 체크때 유용했었음)$/;"	m	struct:s_token	typeref:struct:s_token::s_token
prev	srcs/parse/pipeline.c	/^	t_cmd	*prev;$/;"	m	struct:s_cmd	file:
prev_fd	includes/exec_structures.h	/^	int			prev_fd;$/;"	m	struct:s_info
print_ast	srcs/parse/ast_utils.c	/^void	print_ast(t_ast *ast)$/;"	f
print_export	srcs/builtins/builtin_utils.c	/^int	print_export(t_env_pack *pack)$/;"	f
q_flag	includes/exec_structures.h	/^	char	q_flag;			\/\/ 따옴표 플래그$/;"	m	struct:s_exp_pair
q_flag	includes/structures.h	/^	char	q_flag;			\/\/ 따옴표 플래그$/;"	m	struct:s_exp_pair
redir_fds	includes/exec_structures.h	/^	int			redir_fds[2];		\/\/ 리다이렉션 파이프, 기본값은 표준입출력 fd이고 만약 in_redir, out_redir이 있을때 해당 파일을 open할 때 리턴받은 fd값으로 바꿔준다$/;"	m	struct:s_info
redir_open	srcs/execute/redir_utils.c	/^void	redir_open(t_redir *temp)$/;"	f
redir_open	srcs/execute/redirections/redir_utils.c	/^void	redir_open(t_redir *temp)$/;"	f
relative_execve	srcs/execute/execute_utils2.c	/^void	relative_execve(char **args, t_env_pack *envs, char **envp)$/;"	f
remove_bracket	srcs/parse/bracket.c	/^void	remove_bracket(t_token **start, t_token **end)$/;"	f
remove_space	srcs/parse/tokenizer.c	/^int	remove_space(char *line)$/;"	f
result	includes/exec_structures.h	/^	char		**result;		\/\/ 확장을 완료한 최종 결과물$/;"	m	struct:s_expand
result	includes/structures.h	/^	char		**result;		\/\/ 확장을 완료한 최종 결과물$/;"	m	struct:s_expand
right	includes/exec_structures.h	/^	struct s_ast	*right;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_ast
right	includes/structures.h	/^	struct s_ast	*right;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_ast
right_ptr	includes/structures.h	/^	void		*right_ptr;		\/\/ 오른쪽 branch$/;"	m	struct:s_tree
s_ast	includes/exec_structures.h	/^struct s_ast$/;"	s
s_ast	includes/structures.h	/^struct s_ast$/;"	s
s_cmd	srcs/parse/pipeline.c	/^struct s_cmd$/;"	s	file:
s_cmd_pack	includes/exec_structures.h	/^struct s_cmd_pack$/;"	s
s_cmd_pack	includes/structures.h	/^struct s_cmd_pack$/;"	s
s_env	includes/exec_structures.h	/^struct s_env				\/\/ 환경변수 연결리스트$/;"	s
s_env	includes/structures.h	/^struct s_env				\/\/ 환경변수 연결리스트$/;"	s
s_env_pack	includes/exec_structures.h	/^struct s_env_pack$/;"	s
s_env_pack	includes/structures.h	/^struct s_env_pack$/;"	s
s_exp_pair	includes/exec_structures.h	/^struct s_exp_pair$/;"	s
s_exp_pair	includes/structures.h	/^struct s_exp_pair$/;"	s
s_expand	includes/exec_structures.h	/^struct s_expand$/;"	s
s_expand	includes/structures.h	/^struct s_expand$/;"	s
s_info	includes/exec_structures.h	/^struct s_info$/;"	s
s_list	srcs/libft/libft.h	/^typedef struct s_list$/;"	s
s_mark	includes/parse_struct.h	/^struct s_mark$/;"	s
s_redir	includes/exec_structures.h	/^struct s_redir$/;"	s
s_redir	includes/structures.h	/^struct s_redir$/;"	s
s_token	includes/exec_structures.h	/^struct s_token$/;"	s
s_token	includes/structures.h	/^struct s_token$/;"	s
s_tree	includes/structures.h	/^struct s_tree$/;"	s
scan_n_set_redirs	srcs/execute/redirections.c	/^int	scan_n_set_redirs(t_cmd *cmd, t_env_pack *pack)$/;"	f
scan_n_set_redirs	srcs/execute/redirections/redirections.c	/^int	scan_n_set_redirs(t_cmd *cmd, t_env_pack *pack)$/;"	f
scan_n_setup	srcs/expand/expand.c	/^void	scan_n_setup(t_c_expand *expand, char *data)$/;"	f
search_value	srcs/expand/do_expand.c	/^char	*search_value(t_exp_pair *pair, t_env_pack *pack)$/;"	f
set_fds	srcs/execute/pipe_utils.c	/^void	set_fds(t_cmd *cmd, t_info *info)$/;"	f
set_info	srcs/testmain.c	/^void	set_info(t_info *info)$/;"	f
set_new_env	srcs/envs/build_env_pack.c	/^void	set_new_env(t_env_pack *pack, t_env *new)$/;"	f
set_parse_error	srcs/parse/error.c	/^void	set_parse_error(t_ast *ast, char *string)$/;"	f
set_start_end	srcs/parse/set_nodes.c	/^void	set_start_end(t_ast **ast, t_token *start, t_token *end)$/;"	f
set_type_meta1	srcs/parse/meta.c	/^void	set_type_meta1(char c, int i, t_type *type)$/;"	f
sig_handler	srcs/parse/signal.c	/^void	sig_handler(int signo)$/;"	f
signal_event	srcs/parse/signal.c	/^int	signal_event(void)$/;"	f
smaller	srcs/libft/ft_memmove.c	/^static void	smaller(unsigned char *dst, unsigned char *src, size_t len)$/;"	f	file:
solo_builtin	srcs/builtins/builtin_exec.c	/^int	solo_builtin(t_cmd *cur, t_env_pack *pack)$/;"	f
sorted_head	includes/exec_structures.h	/^	t_env	*sorted_head;	\/\/ 정렬된 순서의 envp head 노드$/;"	m	struct:s_env_pack
sorted_head	includes/structures.h	/^	t_env	*sorted_head;	\/\/ 정렬된 순서의 envp head 노드$/;"	m	struct:s_env_pack
sorted_next	includes/exec_structures.h	/^	struct s_env	*sorted_next;	\/\/ name 기준으로 정렬하였을때의 next node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
sorted_next	includes/structures.h	/^	struct s_env	*sorted_next;	\/\/ name 기준으로 정렬하였을때의 next node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
sorted_prev	includes/exec_structures.h	/^	struct s_env	*sorted_prev;	\/\/ name 기준으로 정렬하였을때의 prev node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
sorted_prev	includes/structures.h	/^	struct s_env	*sorted_prev;	\/\/ name 기준으로 정렬하였을때의 prev node$/;"	m	struct:s_env	typeref:struct:s_env::s_env
split_free	srcs/execute/utils.c	/^void	split_free(char **split)$/;"	f
split_len	srcs/execute/utils.c	/^int	split_len(char **split)$/;"	f
start	includes/exec_structures.h	/^	struct s_token	*start;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_token
start	includes/parse_struct.h	/^	int	start;$/;"	m	struct:s_mark
start	includes/structures.h	/^	struct s_token	*start;$/;"	m	struct:s_ast	typeref:struct:s_ast::s_token
start	srcs/parse/pipeline.c	/^	t_token	*start;$/;"	m	struct:s_cmd	file:
string	includes/exec_structures.h	/^	char			*string;		\/\/ 해당 node의 data$/;"	m	struct:s_token
string	includes/structures.h	/^	char			*string;		\/\/ 해당 node의 data$/;"	m	struct:s_token
syntax_error_parser	srcs/parse/error.c	/^void	syntax_error_parser(char *string, t_token **list)$/;"	f
syntax_error_tokenizer	srcs/parse/error.c	/^void	syntax_error_tokenizer(char *string, t_token **list)$/;"	f
t_ast	includes/exec_structures.h	/^typedef struct s_ast		t_ast;$/;"	t	typeref:struct:s_ast
t_ast	includes/structures.h	/^typedef struct s_ast		t_ast;$/;"	t	typeref:struct:s_ast
t_builtin_ptr	includes/builtin.h	/^typedef int	(*t_builtin_ptr)(char **, t_env_pack *);$/;"	t
t_c_expand	includes/exec_structures.h	/^typedef struct s_expand		t_c_expand;		\/\/ 명령어 확장$/;"	t	typeref:struct:s_expand
t_c_expand	includes/structures.h	/^typedef struct s_expand		t_c_expand;		\/\/ 명령어 확장$/;"	t	typeref:struct:s_expand
t_cmd	includes/exec_structures.h	/^typedef struct s_cmd_pack	t_cmd;$/;"	t	typeref:struct:s_cmd_pack
t_cmd	includes/structures.h	/^typedef struct s_cmd_pack	t_cmd;$/;"	t	typeref:struct:s_cmd_pack
t_cmd	srcs/parse/pipeline.c	/^typedef struct s_cmd t_cmd;$/;"	t	typeref:struct:s_cmd	file:
t_env	includes/exec_structures.h	/^typedef struct s_env		t_env;$/;"	t	typeref:struct:s_env
t_env	includes/structures.h	/^typedef struct s_env		t_env;$/;"	t	typeref:struct:s_env
t_env_pack	includes/exec_structures.h	/^typedef struct s_env_pack	t_env_pack;$/;"	t	typeref:struct:s_env_pack
t_env_pack	includes/structures.h	/^typedef struct s_env_pack	t_env_pack;$/;"	t	typeref:struct:s_env_pack
t_exp_pair	includes/exec_structures.h	/^typedef struct s_exp_pair	t_exp_pair;$/;"	t	typeref:struct:s_exp_pair
t_exp_pair	includes/structures.h	/^typedef struct s_exp_pair	t_exp_pair;$/;"	t	typeref:struct:s_exp_pair
t_info	includes/exec_structures.h	/^typedef struct s_info		t_info;$/;"	t	typeref:struct:s_info
t_list	srcs/libft/libft.h	/^}					t_list;$/;"	t	typeref:struct:s_list
t_mark	includes/parse_define.h	/^typedef struct s_mark	t_mark;$/;"	t	typeref:struct:s_mark
t_r_expand	includes/structures.h	/^typedef struct s_expand		t_r_expand;		\/\/ 리다이렉션 파일 확장$/;"	t	typeref:struct:s_expand
t_redir	includes/exec_structures.h	/^typedef struct s_redir		t_redir;$/;"	t	typeref:struct:s_redir
t_redir	includes/structures.h	/^typedef struct s_redir		t_redir;$/;"	t	typeref:struct:s_redir
t_token	includes/exec_structures.h	/^typedef struct s_token		t_token;$/;"	t	typeref:struct:s_token
t_token	includes/structures.h	/^typedef struct s_token		t_token;$/;"	t	typeref:struct:s_token
t_tree	includes/structures.h	/^typedef struct s_tree		t_tree;$/;"	t	typeref:struct:s_tree
t_type	includes/exec_structures.h	/^typedef enum e_type			t_type;$/;"	t	typeref:enum:e_type
t_type	includes/structures.h	/^typedef enum e_type			t_type;$/;"	t	typeref:enum:e_type
take_bracket	srcs/parse/center.c	/^t_token	*take_bracket(t_token *curr, t_token *start)$/;"	f
this_ptr	includes/structures.h	/^	void		*this_ptr;		\/\/ 현재 노드가 가지고 있는 데이터, cmd타입일때만 내용이 있고 나머지는 NULL$/;"	m	struct:s_tree
this_type	includes/structures.h	/^	enum e_type	this_type;		\/\/ 현재 노드의 타입 (아마 e_type 열거형으로 퉁칠 수 있을듯?)$/;"	m	struct:s_tree	typeref:enum:s_tree::e_type
tokenizer	srcs/parse/tokenizer.c	/^t_token	*tokenizer(char *line)$/;"	f
trim_quotes	srcs/execute/redir_utils.c	/^char	*trim_quotes(char *data)$/;"	f
trim_quotes	srcs/execute/redirections/redir_utils.c	/^char	*trim_quotes(char *data)$/;"	f
type	includes/exec_structures.h	/^	enum e_type		type;		\/\/ 열거형 type$/;"	m	struct:s_token	typeref:enum:s_token::e_type
type	includes/exec_structures.h	/^	enum e_type		type;$/;"	m	struct:s_ast	typeref:enum:s_ast::e_type
type	includes/exec_structures.h	/^	enum e_type	type;			\/\/ 어떤 리다이렉션 타입인지 가르쳐준다$/;"	m	struct:s_redir	typeref:enum:s_redir::e_type
type	includes/structures.h	/^	enum e_type		type;		\/\/ 열거형 type$/;"	m	struct:s_token	typeref:enum:s_token::e_type
type	includes/structures.h	/^	enum e_type		type;$/;"	m	struct:s_ast	typeref:enum:s_ast::e_type
type	includes/structures.h	/^	enum e_type	type;			\/\/ 어떤 리다이렉션 타입인지 가르쳐준다$/;"	m	struct:s_redir	typeref:enum:s_redir::e_type
update_cursor	srcs/testmain.c	/^void	update_cursor(void)$/;"	f
update_list	srcs/parse/tokenizer.c	/^void	update_list(t_token **list, char *string, t_type type)$/;"	f
value	includes/exec_structures.h	/^	char			*value;			\/\/ 환경변수 Value값 ($USER=yusekim 에서 'yusekim' 부분)$/;"	m	struct:s_env
value	includes/structures.h	/^	char			*value;			\/\/ 환경변수 Value값 ($USER=yusekim 에서 'yusekim' 부분)$/;"	m	struct:s_env
write_heredoc	srcs/execute/do_heredoc.c	/^void	write_heredoc(t_redir *redir, t_env_pack *pack, int inf_fd)$/;"	f
write_heredoc	srcs/execute/redirections/do_heredoc.c	/^void	write_heredoc(t_redir *redir, t_env_pack *pack, int inf_fd)$/;"	f
